# Divide Two Integers
==
Divide two integers without using multiplication, division and mod operator.
If it's overflow, return MAX_INT.
## 理解
说一下我最初的思路。
1. 第一个方法是让divisor不断的累加，看看是否超过dividend，同时计算累加的次数。毫无疑问是正确的，但速度慢，尤其是对于divisor==1
2. 第二个但没有实施的方法，是让divisor不断的翻倍。之所以没有实施，是因为我觉得这个方法也有点笨，不像是leetcode应该采用的方法
3. 我去网上找了以下，看到了如下的方法，但开始发现越界的问题不那么简单，比如我无法用abs取得正确的相反数，即便自己判断出正负，直接取负数，仍然无法得到正确的值。
```
二进制完成除法运算就是移位和相减，比如1011011除以1110顺序如下：
          1 - 1110 不够减, 结果添0, 1左移一位再加上原来1后的0,为10
         10 - 1110 不够减, 结果添0, 10左移一位再加上原来10后的1,为101
        101 - 1110 不够减, 结果添0, 101左移一位再加上原来101后的1,为1011
       1011 - 1110 不够减, 结果添0, 1011左移一位再加上原来1011后的0,为10110
      10110 - 1110 = 1000  结果添1，同上左移加原来10110后的1得 10001
      10001 - 1110 = 11    结果添1，同上左移加原来101101后的1得 111
        111 - 1101 不够减，结果添0，此时1011011所有位都已移完，运算完毕
  即 1011011 = 1110 * 0110 + 111
也即 91 = 14 * 6 + 7
由于你相除的两个数放在两个数组中，比如A[]与B[]，要模拟这种运算的话就需要能不
断地从A中取出其二进制的高位，添加到一个当前值的数组C[]中，而实际进
行运算的就是C与B。数组单元的类型必然是多位的，你必须要实现做到对数组C[]左移
一位的操作，剩下的就是判断C够不够减B（即C数组的数是不是比B大）了。

至于左移，我想大家都想到了，其实C和B是倒序存放的，以数组单元为8位为例，
C[0]存放着C的最低8位，用表达式表示就是 C[0] = C & 0xff, C[1] = C & 0xff00, ...
这样当移位时，只要保留当前单元C[i]的最高位，即h = C[i] >> 7，然后直接对
C[i]左移一位即 C[i]<<1，然后再加上上一单元C[i-1]保留的最高位就得到当前的C[i]了。
对于C[0]来说，它的上一单元的最高位自然就是A的最高位了。
```
4. 我开始采用long long，而此时我已经不耐烦了。。。。。。。
5. 安静以下，又去复习了以下int的内存布局：
```
10000000 00000000 00000000 00000000  -2147483648    2147483648
10000000 00000000 00000000 00000001  -2147483647    2147483649
10000000 00000000 00000000 00000010  -2147483646    2147483650
。。。
11111111 11111111 11111111 11111101  -3             4294967293
11111111 11111111 11111111 11111110  -2             4294967294
11111111 11111111 11111111 11111111  -1             4294967295

00000000 00000000 00000000 00000000  0
00000000 00000000 00000000 00000001  1
00000000 00000000 00000000 00000010  2
00000000 00000000 00000000 00000011  3
。。。
01111111 11111111 11111111 11111101  2147483645
01111111 11111111 11111111 11111110  2147483646
01111111 11111111 11111111 11111111  2147483647
```
对于INT_MIN是无法的取反的，所以对其需要用longlong来存储。对于除零，需要特殊对待。
6. 最后实现了#2里面说的方法。