Given a singly linked list, determine if it's a palindrome.
Could you do it in O(n) time and O(1) space?

所谓palindrome, 中文是*回文（指顺读和倒读都一样的词语）*.
那么对于一个单向列表，想要从两端同时向中间遍历，是不可能的。
拷贝到一个新的vector里面，也无法达到O（1）的空间要求。
翻转链表呢？全部翻转显然没有任何用处，翻转到一半？
翻转前半部分的话，需要知道整个长度，否则不知道到哪里截止。
翻转后半部分的话，需要知道从哪里开始。

分开考虑：
* 翻转前半部分：
  我们有head作为头，可以保持不变，分两个指针，一个每次前进一步，一个每次前进两步，后者到头的时候，前者位于前半部分的末尾，为P。
  此时，开始从head开始翻转，到前半部分末尾P，现在有两个list，一个从P开始向左，一个从P＋1开始向右。这样很不好比较，因为不知道从P＋1开始比较还是从P＋2开始比较。应该希望从两端开始进行比较，就是说，最后形成的两个list的head，一个应该是原来的head，一个是原来的end。由此推断，应该翻转后半部分。
* 翻转后半部分：
  翻转后，拿到两个list，一个head，一个end，开始进行比较，两个截止条件，一个是遇到不想等的，一个是head list到头。